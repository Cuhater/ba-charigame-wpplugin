\chapter{Implementierung}
\label{chap:implementation}
Auf Basis der in Kapitel 4 entwickelten Konzeption folgt in diesem Kapitel die praktische Umsetzung.
Dabei werden die einzelnen Komponenten des Systems beschrieben und ihre Implementierung im Rahmen des WordPress-Plugins erläutert.
Neben technischen Aspekten wie der Strukturierung von Backend und Frontend sowie der Integration des Gutenberg-Editors wird auch auf die Realisierung der funktionalen Anforderungen eingegangen.

\section{Entwicklungsumgebung und Tools}
Für die Umsetzung des Projekts wurden verschiedene Tools eingesetzt.
Als Entwicklungsumgebung kam PHPStorm zum Einsatz, ergänzt durch PHPCS zur Einhaltung der WordPress-Codestandards.
Google Chrome diente als Browser, während die lokale Entwicklung mit Local WP eingerichtet wurde.
Zur Verwaltung von Paketen und Abhängigkeiten wurde \texttt{npm} verwendet und die Versionierung des Projekts erfolgte über GitHub.

\section{Projektsetup}
Im ersten Schritt der Implementierung wurde eine lokale Entwicklungsumgebung mittels Local WP eingerichtet.
Die Entwicklungsumgebung basiert auf einem nginx-Webserver mit PHP Version 8.4.10 und einer MySQL-Datenbank in Version 8.0.35.
WordPress wurde in der Version 6.8.2 installiert und mit den Standardkonfigurationen eingesetzt.
Es wurden keine zusätzlichen Anpassungen an der Grundkonfiguration vorgenommen und keine weiteren Plugins implementiert, um eine möglichst neutrale Ausgangsbasis für die Implementierung zu gewährleisten.

Zwecks Versionierung wurde Git auf der GitHub-Instanz der elancer-team GmbH verwendet und ein neuer Branch im bestehenden Repository angelegt.
Der deskriptive Stand des Plugins wurde abschließend in WordPress importiert und die eigentliche Implementierung begonnen.

\section{Plugin-Struktur und Architektur}
\textbf{Ausgangsbasis und Bereinigung}

Als Ausgangsbasis für die Implementierung wurde die WordPress Plugin Boilerplate von DevinVinson\footnote{\url{https://github.com/DevinVinson/WordPress-Plugin-Boilerplate}} verwendet.
Diese Vorlage bietet eine standardisierte Struktur für WordPress-Plugins und folgt den offiziellen WordPress-Entwicklungsrichtlinien im Hinblick auf die Best Practises.

Im ersten Schritt wurden die zuvor importierten Daten aus dem bestehenden Plugin-Stand eingesetzt und eine umfassende Bereinigung durchgeführt.
Dabei wurden nicht verwendete Dateien identifiziert und entfernt.
Zu diesen Altlasten zählten diverse Assets und Abhängigkeiten, die bereits zum Zeitpunkt des Transfers keine Funktion mehr erfüllten oder redundant wurden.
\\\\
\textbf{Migration zu Carbon Fields}

Entsprechend der Konzeption und Anforderung [T1] wurde Carbon Fields als Ersatz für ACF Pro implementiert.
Hierzu wurde eine dedizierte Klasse für den Boot-Prozess von Carbon Fields erstellt und über Composer als Abhängigkeit in die neue Projektstruktur eingebunden.
Die Initialisierung erfolgt über einen Klassenaufruf, der das Framework zentral verfügbar macht.

Alle bestehenden \texttt{get\_field()}-Aufrufe des ursprünglich verwendeten ACF Plugins wurden systematisch identifiziert und durch das entsprechenden Carbon Fields-Pendant ersetzt.
Diese Migration gewährleistet die Kompatibilität mit der neuen Architektur und eliminiert die externe Abhängigkeit von ACF Pro vollständig.
\\\\
\textbf{Custom Post Types und REST API}

Alle Custom Post Types wurden neu aufgebaut, um einen einheitlichen Duktus innerhalb des ChariGame-Plugins zu realisieren.
In diesem Schritt wurden die Namespace-Bezeichnungen angepasst und Klassen- sowie Datenbankbezeichnungen vereinheitlicht.

Bei der Neudefinition der CPTs wurden wichtige Eigenschaften für die REST API freigegeben, um diese im Backend-Editor über React abrufen zu können.
Dies ist essenziell für die Umsetzung der Gutenberg-Blöcke und deren dynamische Eigenschaften, da diese auf Kampagnendaten und verknüpfte Inhalte zugreifen.
Hier wurden unter anderem Daten des game_type, der game_settings, der linked_landing_page und der recipients innerhalb der internen Rest Schnittstelle wp/json REST freigegeben.
\\\\
\textbf{Verzeichnisstruktur und Design-System}

Die Verzeichnisstruktur wurde modular aufgebaut und wie in Tabelle~\ref{tab:directory-structure} dargestellt organisiert:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Verzeichnis} & \textbf{Inhalt} \\
        \hline
        \texttt{includes/} & Kernfunktionalitäten und Klassen \\
        \texttt{admin/} & Backend-spezifische Komponenten, shadcn/ui-Styles \\
        \texttt{frontend/} & Frontend-Darstellung und Templates \\
        \texttt{blocks/} & Gutenberg-Block-Definitionen \\
        \texttt{assets/} & Statische Ressourcen (CSS, JS, Bilder, Icons) \\
        \texttt{src/} & Quellcode der Block-Entwicklung und Spiele  \\
        \texttt{templates/} & Template-Dateien für die Darstellung \\
        \hline
    \end{tabular}
    \caption{Verzeichnisstruktur des Plugins}
    \label{tab:directory-structure}
\end{table}

%TODO HIER ERSTMAL AUF DAS ALLGEMEINE TAILWIND EINGEHEN DANN ERST AUF SHADCN
Zusätzlich wurde eine Tailwind CSS-Konfiguration aufgebaut mit einer PHP-portierten shadcn/ui-Implementierung.
Diese nutzt einen \texttt{shadcn--}-Prefix, um Konflikte mit WordPress-Styles zu vermeiden.
Die Styles liegen als vorgebaute CSS-Dateien in \texttt{admin/css/} und werden nur auf ChariGame-Admin-Seiten geladen.
\\\\
\textbf{Asset Manager und Template Loader}

Ein Asset Manager wurde implementiert, der selektiv die passenden Assets für Admin- und Frontendbereich lädt.
\begin{itemize}
    \item \textbf{Admin}: Shadcn/Tailwind-Styles für die ChariGame-Menüs und -Seiten
    \item \textbf{Frontend}: Game-Styles/-Skripte und lokalisierte Daten nur auf Seiten von Charigame
\end{itemize}

Der Template Loader stellt sicher, dass Campaign-Inhalte das korrekte Template erhalten und führt bei Bedarf Redirects durch.
Für den Custom Post Type der Landingpages wurde festgelegt, dass diese nicht eigenständig betrachtet werden, sondern den Content ausschließlich in den Campaign-Templates ausgeben.
\\\\
\textbf{Login-System und Sicherheit}

Die Login-Logik wurde aus dem Frontend separiert und in einen dedizierten Login Manager überführt.
Das System implementiert mehrere Sicherheitsmaßnahmen:

\begin{itemize}
    \item \textbf{Nonce-Validierung}: \texttt{wp\_verify\_nonce()} schützt AJAX-Endpoints
    \item \textbf{Input-Sanitizing}: \texttt{sanitize\_text\_field()}, \texttt{intval()} für Benutzereingaben
    \item \textbf{Session-Management}: Sessions werden früh gestartet und konsistent genutzt
    \item \textbf{Caching}: Datenbank- und User-Lookups werden im Object Cache gepuffert
\end{itemize}

Darüber hinaus wurde ein Shortcode erstellt, der den Content der Landingpages überträgt und diesen in die Campaign-Templates einsetzt.
Dies ermöglicht eine flexible Wiederverwendung der Landingpage-Inhalte.
\\\\
\textbf{Color Manager}

Der Color Manager verwaltet Kampagnenfarben und stellt diese systemweit zur Verfügung.
Die Implementierung erfolgt als Singleton-Klasse, die folgende Funktionen bereitstellt:

\begin{itemize}
    \item Automatische Kampagnen-Erkennung über URL-Kontext
    \item CSS-Variablen für den Frontend- und Adminbereich (\texttt{--color-primary}, etc.)
    \item JavaScript-Objekt \texttt{charigameColors} für den Block-Editor
    \item Fallback auf Standard-Farbpalette
\end{itemize}

\section{Gutenberg-Block-Entwicklung}
\textbf{Block-Architektur}

Ein wesentlicher Bereich der Implementierung war der Aufbau der Gutenberg-Blöcke.
Die Registrierung erfolgt im Projekt automatisiert über die Hauptklasse \texttt{ChariGame\_Blocks}, die alle Blöcke in \texttt{src/blocks/} mit vorhandener \texttt{block.json} registriert.

Für das ChariGame Plugin wurde ein Block-Whitelisting implementiert, das nur die plugin-eigenen Blöcke zulässt.
Dies gewährleistet eine konsistente Benutzererfahrung und verhindert Layout-Inkonsistenzen.
\\\\
\textbf{Kern-Blöcke der Landingpage}

Die implementierten Blöcke spiegeln den Stand der Weiterentwicklung wider und sind vollständig über den Gutenberg-Editor anpassbar:

\begin{itemize}
    \item \textbf{Intro Section}: Hero-Bereich mit konfigurierbare Farben und Typografien
    \item \textbf{Donation Section}: Dynamische Spendenverteilungs-Visualisierung
    \item \textbf{How-to-Play Section}: Spielanleitung mit HeroIcons Integration
    \item \textbf{Recipient Section}: Darstellung der Spendenempfänger
    \item \textbf{Game Section}: Templatebasierte Spielintegration
\end{itemize}

Jeder Block implementiert serverseitiges Rendering bereitgestellte über \texttt{render.php}-Dateien, um dynamische Inhalte und bessere Performance zu gewährleisten.
\\\\
\textbf{Block-Utilities und Komponenten}

Zur Unterstützung der Block-Entwicklung wurden verschiedene Utilities entwickelt, damit Codedopplungen vermieden werden:

\begin{itemize}
    \item \textbf{colorpalette}: Einheitliches Farbauswahl-Interfaces
    \item \textbf{iconlist}: Heroicons-Integration mit SVG-Inline-Rendering
    \item \textbf{useimage}: Medien-Handling für Block-Attribute
    \item \textbf{usecampaigndata}: Kampagnendaten-Integration für dynamische Blöcke
\end{itemize}

Ferner wurden Komponenten wie \texttt{BackgroundSelect} und \texttt{BorderStyle} ausgelagert, um Konstante zentral abrufen zu können.
\\\\
\textbf{Donation Manager Integration}

Während der Implementierung wurde festgestellt, dass die bestehende Spendenverteilungs-Logik nicht mehr funktionierte.
Ein neuer Donation Manager wurde entwickelt, der die folgenden Aufgaben der Spendenverteilung übernimmt:

\begin{itemize}
    \item Kampagnen-Statistiken berechnen und cachen
    \item Spendenverteilung nach konfigurierbaren Regeln durchführen
    \item Echtzeit-Updates für die Donation Section bereitstellen
    \item Rundungs- und Formatierungslogik implementiert
\end{itemize}

\section{Backend-Integration und Dashboard}
\textbf{Dashboard-Modernisierung}

Das bestehende Dashboard wurde vollständig überarbeitet und mit shadcn/ui-Komponenten integriert.
Die neue Lösung bietet u.a. die folgenden Funktionen:

\begin{itemize}
    \item Responsive Design mit modernen UI-Komponenten
    \item Erweiterte Kampagnen-Metriken und Analytics
    \item Verbesserte Benutzererfahrung durch intuitive Navigation
    \item Echtzeit-Datenaktualisierung
\end{itemize}
\\\\
\textbf{Admin-Komponenten-System}

Für die Admin-Oberfläche wurden wiederverwendbare PHP-Komponenten entwickelt, welche im Styling auf der Bibliothek Shadcn/ui basieren:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Komponente} & \textbf{Zweck} \\
        \hline
        \texttt{Button} & Konsistente Button-Darstellung mit verschiedenen Varianten \\
        \texttt{Card} & Karten-Layout für strukturierte Inhaltsblöcke \\
        \texttt{Progress} & Fortschrittsanzeigen für Kampagnen-Status \\
        \texttt{Table} & Tabellarische Datendarstellung mit Sortierung \\
        \hline
    \end{tabular}
    \caption{Admin-Komponenten-Übersicht}
    \label{tab:admin-components}
\end{table}
\\\\
\textbf{E-Mail-System und SMTP-Integration}

Ein umfassendes E-Mail-Template-System wurde implementiert, das HTML-Templates als Custom Post Type im Block-Editor verfügbar macht.
Dies bietet die Möglichkeit, dass der Nutzer das Template der Einladungs-Mail direkt im Live-Editor anpassen kann.
Die SMTP-Konfiguration wurde als wiederverwendbares Partial entwickelt und nutzt ebenfalls Shadcn-Komponenten.
\\\\
\textbf{Helper-Funktionen und API}

Die zentrale \texttt{helper.php}-Datei wurde während der Implementierung kontinuierlich erweitert und verfügt über die folgenden Funktionen:

\begin{itemize}
    \item Getter- und Setter-Funktionen für die Plugin-Komponenten
    \item AJAX-Action-Registrierung für die Frontend-Backend-Kommunikation
    \item Eine Konsistente Schnittstelle für Datenabruf und -manipulation
    \item Cache-Management für Performance-Optimierung
\end{itemize}

\section{Spielintegration und Einstellungen}
Die bestehenden Spiele wurden in die neue Architektur übernommen.
Individuelle Einstellungsmöglichkeiten wurden in ein separates Settings-System ausgelagert, um eine flexiblere Konfiguration und bessere Wartbarkeit zu gewährleisten.
Durch das Auslagern besteht nun die Möglichkeit die hinterlegten Spieleinstellungen mehreren Kampagnen zuzuordnen.
Der entwickelte Gutenberg-Block für die Game-Section ermöglicht die dynamische Einbindung verschiedener Spieltypen über ein Template-basiertes System, das in \texttt{src/games/} organisiert ist.

\section{Qualitätssicherung und Standards}
Während der gesamten Implementierung wurden WordPress-Best-Practices befolgt:

\begin{itemize}
    \item PHPCS-Integration für automatisierte Code-Standards-Prüfung
    \item Nonce-Validierung für alle AJAX-Requests
    \item Input-Sanitizing und Output-Escaping
    \item Objektorientierte Programmierung mit klarer Verantwortungstrennung
    \item Modularität für bessere Testbarkeit und Wartung
\end{itemize}

Die Implementierung adressiert die definierten Anforderungen [T1-T3] und [F1-F5] und schafft eine solide Basis für zukünftige Erweiterungen.
